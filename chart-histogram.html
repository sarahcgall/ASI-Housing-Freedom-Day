<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noindex,nofollow">
    <title>Cost of Rent Histogram</title>

    <!-- Load Pym.js  -->
    <script type="text/javascript" src="https://pym.nprapps.org/pym.v1.min.js"></script>
</head>

<body>

<div>
    <h2 style="margin-bottom: 0;">Title</h2>
    <p style="margin-top: 5px;">Number of counties by Cost of Rent Day by week and region</p>
</div>

<!-- Container for the calendar chart -->
<div id="histogramchart"></div>

<div>
    <p style="margin-top: 5px;">Data Source: Annual Pay - Gross & Private Rental Market Statistics, Office of National Statistics UK | Chart: Sarah C Gall</p>
    <p style="margin-top: 0;">* Cost of Rent Day is calculated as the proportion of median income multiplied by 365.25 days</p>
</div>

<!-- d3.js chart -->
<script type="module">

    // Import d3 to use in vanilla HTML (using CDN-hosted ES module bundle)
    import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

    // Store the reference to the div element
    const chartDiv = document.getElementById('histogramchart');

    // Declaring variables
    const calendarYear = 2024;
    const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; // Set months
    const csvFile = 'Regional Data.csv'; // Path to your CSV file
    let regionData = []; // Initialise regionData
    let svg, x, y; // Define svg, x, and y
    let lastRegion = 'England' // store most recent region (on load = England)
    let lastFreedomDay = null; // store most recent freedomDay

    // DATASET =========================================================================================================
    // Asynchronous function to fetch and process data
    async function fetchData() {
        try {
            const rawData = await d3.csv(csvFile);
            // Filter Counties only and remove NAs/missing values from Day of the year
            const filteredData = rawData.filter(function (d) {
                return d.Category === "County" && d["Day of the year"];
            });
            const parsedData = filteredData.map(d => {
                // Parse the date once, use for both
                const date = d3.timeParse("%m/%d/%Y")(d["Day of the year"]);
                return [
                    {
                        region: d.ParentRegion,
                        countyName: d.Name,
                        freedomDate: date,
                        proportion: +d["Rent as a share of income"]
                    },
                ];
            }).flat(); // Flatten the array of arrays into a single array
            return parsedData;
        } catch (error) {
            console.error("Error loading data:", error);
            return [];
        }
    }

    // SETUP FUNCTIONS =================================================================================================
    // Function to adjust margin
    function setDimensions(svgWidth) {
        // Set base width of chart area
        const baseWidth = 640;

        // Set base height dependent on screen size
        const aspectRatio = svgWidth > 650 ? 0.4 : svgWidth > 350 ? 0.75 : 1;

        // Calculate base height based on aspect ratio
        const baseHeight = baseWidth * aspectRatio;

        // Calculate scaling factor for responsive designs
        const scaleFactor = baseWidth / svgWidth;

        // Calculate margins based on svgWidth
        let margin
        if (svgWidth < 350) {
            margin = {
                top: 30,
                right: 80,
                bottom: 160,
                left: 10
            };
        } else if (svgWidth < 650) {
            margin = {
                top: 20,
                right: 50,
                bottom: 80,
                left: 10
            };
        } else {
            margin = {
                top: 20,
                right: 30,
                bottom: 60,
                left: 10
            };
        }

        // Calculate width and height using the margins
        const width = baseWidth - margin.left - margin.right;
        const height = baseHeight - margin.top - margin.bottom;

        // Return the baseWidth, baseHeight, margin, width, height and scaleFactor
        return {baseWidth, baseHeight, margin, width, height, scaleFactor};
    }

    // Function to set up the
    function setupSVG(baseWidth, baseHeight, margin) {
        // Clear previous SVG elements
        d3.select(chartDiv).select("svg").remove();

        // Create the SVG container with viewBox for responsive sizing
        const svg = d3.select(chartDiv).append("svg")
            .attr("viewBox", `0 0 ${baseWidth} ${baseHeight}`)
            .attr("preserveAspectRatio", "xMidYMid meet")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("overflow", "hidden")
            .append("g")
            .attr("transform", `translate(${margin.left}, ${margin.top})`);

        return svg;
    }

    // Function to adjust text size based on SVG width
    function adjustTextSize(scaleFactor) {
        // Determine wrapping width based on screen size
        const spacing = window.innerWidth > 350 ? 160 : 110

        // Y-Axis Title
        d3.selectAll(".y-axis text")
            .style("font-size", `${14 * scaleFactor}px`);

        // X-Axis Title
        d3.selectAll(".x-axis-title")
            .style("font-size", `${14 * scaleFactor}px`)
            .attr("y", 40 * scaleFactor); // Adjust the position to be slightly below the x-axis

        // X-Axis Title
        d3.selectAll(".x-axis-title2")
            .style("font-size", `${13 * scaleFactor}px`)
            .attr("y", 60 * scaleFactor); // Adjust the position to be slightly below the x-axis

        // Legend
        d3.selectAll(".legendEntry text")
            .style("font-size", `${14 * scaleFactor}px`);

        // adjust legend position
        d3.selectAll(".legendEntry")
            .attr("transform", (d, i) => `translate(${i * spacing * scaleFactor}, 0)`);

        // Tick Text
        d3.selectAll(".tick text")
            .style("font-size", `${13 * scaleFactor}px`)
    }

    // SCALE & AXES FUNCTIONS ==========================================================================================
    // Function to set up the scales
    function setupScales(width, height) {
        // Create a time scale for X-axis (months)
        const xScale = d3.scaleTime()
            .domain([new Date(calendarYear, 0, 1), new Date(calendarYear, 11, 31)])
            .range([0, width]);

        // Create a linear scale for Y-axis (count data) // Create an ordinal scale for Y-axis (days)
        const yScale = d3.scaleLinear()
            .range([height, 0]);

        return {xScale, yScale};
    }

    // Function to determine the middle of the month to place labels
    function middleOfMonth(year, month) {
        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        const middleDay = Math.ceil((lastDay.getDate() - firstDay.getDate()) / 2) + firstDay.getDate();
        return new Date(year, month, middleDay);
    }

    // Function to draw axes
    function drawAxes(svg, xScale, yScale, svgWidth, height, width) {
        // Calculate middle of each month for ticks
        const monthTicks = d3.range(0, 12, svgWidth > 650 ? 1 : svgWidth > 350 ? 2 : 3)
            .map(month => middleOfMonth(calendarYear, month));

        // Add X-axis at the bottom
        const xAxis = svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(xScale)
                .tickValues(monthTicks) // One tick per month
                .tickSize(0)
                .tickFormat(d3.timeFormat('%b'))); // Abbreviated month name

        // Add X-axis title at the top
        xAxis.append("text")
            .attr("class", "x-axis-title")
            .attr("x", width / 2) // Center the label
            .attr("y", 40)
            .style("fill", "black")
            .style("text-anchor", "middle") // Center the text at the x-position
            .text("Date of Cost of Rent Day");

        xAxis.append("text")
            .attr("class", "x-axis-title2")
            .attr("x", width / 2)
            .attr("y", 60)
            .style("fill", "black")
            .style("text-anchor", "middle")
            .text("(Week of Year)");

        // Add Y-axis
        const yAxis = svg.append("g")
            .attr("class", "y-axis")
            .attr("transform", "translate(" + width + ",0)")
            .call(d3.axisRight(yScale)
                .ticks(5)
                .tickSize(0)
                .tickFormat(d3.format(".0f")));  //  Format as a floating-point number with no decimals, which is good for counts

        // Remove axis line
        yAxis.select(".domain").remove();

        // Add Y-axis title at the top
        yAxis.append("text")
            .attr("transform", "translate(10,-10)")
            .style("text-anchor", "end")  // Align text to the end side
            .text("Number of counties")
            .style("fill", "black");

    }

    // BASE DATA FUNCTIONS =============================================================================================
    function createWeeklyBins(data, xScale) {
        // Helper function to generate an array of dates, one per week
        function weekRange(startDate, endDate) {
            let currentDate = new Date(startDate.getTime());
            let weeks = [];
            while (currentDate < endDate) {
                weeks.push(new Date(currentDate));
                currentDate.setDate(currentDate.getDate() + 7);
            }
            return weeks;
        }

        const firstDayOfYear = xScale.domain()[0];
        const lastDayOfYear = new Date(firstDayOfYear.getFullYear(), 11, 31);
        const weeks = weekRange(firstDayOfYear, lastDayOfYear);

        const histogram = d3.histogram()
            .value(d => d.freedomDate)
            .domain(xScale.domain())
            .thresholds(weeks); // Set thresholds to weekly

        return histogram(data);
    }

    // PLOTTING FUNCTIONS ==============================================================================================
    function calculateSquareSize(data, height) {
        // Calculate the max number of items in any bin
        const maxItems = d3.max(data, d => d.length);
        const padding = 0.5; // Minimum padding
        const availableHeightPerItem = height / maxItems - padding;
        return Math.min(20, availableHeightPerItem); // Ensure squares are not larger than 20px
    }

    function drawHistogram(svg, xScale, yScale, height) {
        // Get weekly bins directly from the createWeeklyBins function
        const bins = createWeeklyBins(regionData, xScale);
        // Define square size and padding
        const squareSize = calculateSquareSize(bins, height);
        const padding = 0.5;

        // Calculate max height needed for the tallest stack
        yScale.domain([0, Object.keys(bins).length]);  // Reset yScale domain based on actual data

        // Create a color scale for regions
        const colorScale = d3.scaleOrdinal(d3.schemeCategory10)
            .domain(regionData.map(d => d.region));

        // Bind your data to rectangles (bars)
        const bar = svg.selectAll(".bar")
            .data(bins)
            .enter().append("g")
            .attr("class", "bar")
            .attr("transform", d => `translate(${xScale(d.x0)}, ${height - (squareSize + padding) * d.length})`);

        // Draw squares within each bin
        bar.each(function (binData, i) {
            const g = d3.select(this);
            let yOffset = 0;

            binData.forEach((d, index) => {
                g.append("rect")
                    .attr("x", 1)
                    .attr("y", yOffset)
                    .attr("width", xScale(bins[0].x1) - xScale(bins[0].x0) - 1)
                    .attr("height", squareSize)
                    .attr("fill", colorScale(d.region))
                    .attr("stroke", "#fff");

                yOffset += squareSize + padding;  // Move yOffset for the next square
            });
        });
    }

    // LEGEND ==========================================================================================================
    // Add Legend


    // TOOLTIP =========================================================================================================
    // Globacl initialisation of tooltip
    let tooltip = d3.select(chartDiv).select(".tooltip");
    if (tooltip.empty()) {
        tooltip = d3.select(chartDiv)
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0)
            .style("position", "absolute")
            .style("pointer-events", "none")
            .style("background-color", "white")
            .style("max-width", "150px")
            .style("text-align", "center")
            .style("font-size", "12px")
            .style("border", "solid 1px #ccc")
            .style("border-radius", "5px")
            .style("padding", "10px")
            .style("box-shadow", "0px 2px 10px rgba(0,0,0,0.1)");
    }

    // Formatter for adding commas into long numbers
    const formatter = new Intl.NumberFormat('en-GB', {
        style: 'decimal',
        maximumFractionDigits: 0
    });

    // Function to dynamically adjust tooltip position
    function adjustTooltipPosition(event, tooltip) {
        const tooltipWidth = 150; // Approximate width of the tooltip
        const tooltipHeight = 150; // Approximate height of the tooltip
        const padding = 20; // Padding from the edges of the viewport

        // Coordinates where the tooltip should appear
        let xPosition = event.pageX;
        let yPosition = event.pageY;

        // Check if the tooltip would go out of bounds
        if (xPosition + tooltipWidth > window.innerWidth) {
            xPosition = event.pageX - tooltipWidth; // Flip to the left side
        }

        if (yPosition + tooltipHeight > window.innerHeight) {
            yPosition = event.pageY - tooltipHeight; // Flip above the cursor
        }

        tooltip
            .style("left", `${xPosition}px`)
            .style("top", `${yPosition}px`);
    }

    function removeTooltip(tooltip) {
        tooltip
            .transition()
            .duration(500)
            .style("opacity", 0);
    }


    // DRAW CHART ======================================================================================================
    function drawChart() {
        // Use the viewport width to determine width of svg container
        const svgWidth = chartDiv.clientWidth;

        // Get dimensions parameters from getDimensions function
        const {baseWidth, baseHeight, margin, width, height, scaleFactor} = setDimensions(svgWidth);

        // Setup SVG using the setupSVG function
        svg = setupSVG(baseWidth, baseHeight, margin);

        // Setup scales
        const {xScale, yScale} = setupScales(width, height);

        // Draw Histrogram
        drawHistogram(svg, xScale, yScale, height)

        // Draw axes
        drawAxes(svg, xScale, yScale, svgWidth, height, width);

        // Adjust text size
        adjustTextSize(scaleFactor);

    }

    // RESPONSIVE CHART ================================================================================================
    // Declare pymChild in the global scope if it's used globally
    var pymChild;

    // Function to initialise and load data (only once)
    async function initialiseChart() {
        regionData = await fetchData(); // Load and parse the data
        if (Object.keys(regionData).length === 0) {
            console.error("No data available to draw the chart.");
            return; // Exit if data is not available
        }
        responsiveChart();
    }

    // Function to draw the chart and handle responsiveness
    function responsiveChart() {
        if (Object.keys(regionData).length === 0) {
            console.error("Data not ready when responsiveChart called.");
            return;
        }

        drawChart(); // draw the chart

        if (typeof pymChild !== 'undefined') {
            pymChild.sendHeight(); // Send height to iframe for resize only if pymChild is defined
        }
    }

    // Initial Load
    document.addEventListener("DOMContentLoaded", function () {
        try {
            pymChild = new pym.Child({polling: 500}); // Setup with polling interval if needed
            initialiseChart();
        } catch (error) {
            console.error("Error initialising pymChild:", error);
        }
    });

    // On Resize
    d3.select(window).on("resize", responsiveChart);

</script>
</body>
</html>